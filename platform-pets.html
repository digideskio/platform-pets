<!--
	Pet Platformers Game

	Author: John Shaughnessy and Abdullah Yousufi
	Copyright (c) 2015 Altspace VR
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Pets Platformer</title>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="three.min.js"></script>
		<script src="stats.min.js"></script>
		<script src="OrbitControls.js"></script>

		<!-- Required by OBJMTLLoader.js -->
		<script src="AltspaceSDK/lib/OBJMTLLoader.js"></script>
		<script src="AltspaceSDK/lib/MTLLoader.js"></script>
		<script src="AltspaceSDK/lib/firebase.js"></script>

		<script src="AltspaceSDK/src/cursor/CursorEvents.js"></script>
		<script src="AltspaceSDK/src/cursor/AltObjectControls.js"></script>
		<script src="AltspaceSDK/src/sync/FirebaseSync.js"></script>

		<script src="AltspaceSDK/src/cursor/ColorHoverEffect.js"></script>
		<script src="AltspaceSDK/src/cursor/DragPlaneEffect.js"></script>

		<script src="PerlinNoise.js"></script>

		<!-- keyboard events -->
		<script src="threex.keyboardstate.js"></script> 
		

		<script src="GSAP/tween.min.js"></script>
	    <script src="GSAP/EasePack.min.js"></script>
	    <script src="GSAP/TweenLite.min.js"></script>
	    <script src="GSAP/TweenMax.min.js"></script>
	    <script src="GSAP/TimelineLite.min.js"></script>
		<style>
			body {
				font-family: Monospace;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
		</style>

	</head>
	<body>
		<div id="info"></div>
		<div id="viewport"></div>

		<script>

			var inAltspace = window.hasOwnProperty('altspace');

			var scene, camera, renderer, altRenderer, controls;
			var cursorEvents, firebaseSync;
			var loader;
			var sound;
			var stats;
			var platformAnimations = [[]];
			

			var keyboard;

			var prevTimestamp = 0;
			var perlin2D, perlin3D;
			var pet;
			var once = false;
			var collidableObjects = [];
			var raycaster = new THREE.Raycaster();
			var thingYouLastSteppedOn;
			var yourHeightWhenYouWereLastOnTheGround = 0;
			var sceneCorrection = 410;

			loadModels();

			function loadModels() {

				var loader = new THREE.OBJMTLLoader();

				// loader assumes .mtl file has same basename as .obj file
				// var objFilename = "AltspaceSDK/examples/models/AltspaceCube/cube.obj";
				// loader.load(objFilename, function ( loadedObject ) {
				// 	onModelsLoaded();
				// });
				onModelsLoaded();
				// NO CODE HERE unless you want it to run before models finish loading.
			}

			function onModelsLoaded() {

				initScene();
				initSync();

				keyboard = new THREEx.KeyboardState();

			}

			function onSyncReady() {

				initEvents();
				animate(prevTimestamp);

			}
			
			function initScene() {

				scene = new THREE.Scene();

				var container = document.createElement( 'div' );
				document.body.appendChild( container );
				if ( inAltspace ) {

					altRenderer = altspace.getThreeJSRenderer({version: '0.2.0'});
					// hide any elements on webpage
					document.getElementById("info").style.visibility = "hidden";

					// Place the cube at the bottom of the enclosure.
					//scene.position.y = ( -1 * window.innerHeight / 2 );

				}
				else{
					renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
					renderer.setClearColor(0x0000ff, 0.4);
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( renderer.domElement );

					var aspect = window.innerWidth / window.innerHeight;
					camera = new THREE.PerspectiveCamera( 70, aspect, 1, 2000 );
					camera.position.z = 800;
					camera.position.y = 300;
					camera.lookAt( scene.position );

					controls = new THREE.OrbitControls(camera, renderer.domElement);

				}
				// OBJMTLLoader always uses PhongMaterial, so we need light in scene.
				var ambient = new THREE.AmbientLight( 0xffffff );
				scene.add( ambient );

				pointLight = new THREE.PointLight( 0xffffff, 1.75 );
				scene.add( pointLight );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				
				// pet
				pet = new THREE.Mesh(new THREE.BoxGeometry(20,20,20), new THREE.MeshBasicMaterial({ opacity: 0.5, color: 0x0000ff, transparent: true, map: THREE.ImageUtils.loadTexture('images/polka.png') }));
				pet.position.x = 0;
				pet.position.y = 700 - sceneCorrection;
				pet.position.z = 0;
				scene.add(pet);

  				// procedural environment
				perlin2D = new PerlinNoise(0.5, 1.0, 3, 2);
				var numX = 15;
				var numZ = 15;
				var spacing = 1;
				var blockGeometry = new THREE.BoxGeometry( 40, 40, 40 );
				var grassMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, map: THREE.ImageUtils.loadTexture('images/grass.jpg') });
				var dirtMaterial = new THREE.MeshBasicMaterial({ color: 0x996633, map: THREE.ImageUtils.loadTexture('images/dirt.jpg') });
				var grassMesh;
				for(var i = 0; i <= numX * spacing ; i+=spacing){
					for(var j = 0; j <= numZ * spacing; j+=spacing){
						grassMesh = new THREE.Mesh(blockGeometry, grassMaterial);
						grassMesh.position.y = perlin2D.perlinNoise2D(i, j) * 150 - sceneCorrection;
						grassMesh.position.x = i * 40 - numX * 20;
						grassMesh.position.z = j * 40 - numZ * 20;
						collidableObjects.push(grassMesh);
						scene.add(grassMesh);
						
						var noise = perlin2D.noise2D(i, j);
						var moveX = 0;
						var moveY = 0;
						var moveZ = 0;
						var scale = 50;
						if(noise < -0.66){
							moveX = noise * scale;
						}
						else if(noise >= -0.66 && noise <= 0.33){
							moveY = noise * scale * 4;
						}
							else if (noise > 0.33){
							moveZ = noise * scale;
						}
						for(var k = 0; k <= ((i * j) % 15) / 3 ; k++){
							var dirtMesh = new THREE.Mesh(blockGeometry, dirtMaterial);
							dirtMesh.position.x = grassMesh.position.x;
							dirtMesh.position.y = (grassMesh.position.y - (k+1) * 40) ;
							dirtMesh.position.z = grassMesh.position.z;
							if(!inAltspace){
								//var anim = new TimelineMax({repeat: 0});
							 //   anim.to(dirtMesh.position, noise + 5, {x: dirtMesh.position.x + moveX, y: dirtMesh.position.y + moveY, z: dirtMesh.position.z + moveZ, ease:Power0.easeOut});
								//anim.to(dirtMesh.position, noise + 5, {x: dirtMesh.position.x, y: dirtMesh.position.y, z: dirtMesh.position.z, ease:Power0.easeIn});
							}
							collidableObjects.push(dirtMesh);
							scene.add(dirtMesh);
							
						}
						if(!inAltspace){
							//var anim = new TimelineLite({repeat: 0});
							//anim.to(grassMesh.position, noise + 5, {x: grassMesh.position.x + moveX, y: grassMesh.position.y + moveY, z: grassMesh.position.z + moveZ, ease:Power0.easeOut});
							//anim.to(grassMesh.position, noise + 5, {x: grassMesh.position.x, y: grassMesh.position.y, z: grassMesh.position.z, ease:Power0.easeIn});
						}
						
					}
				}
				perlin3D = new PerlinNoise(2.0, 10, 5, 0);
				var cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true, map: THREE.ImageUtils.loadTexture("images/sky.jpg")});
				for(var x = 0; x <= numX; x++){
					for(var y = 0; y <= 10; y++){
						for(var z = 0; z <= numZ; z++){
							if(perlin3D.perlinNoise3D(x, y, z) > 0.7){
								var cloudMesh = new THREE.Mesh(blockGeometry, cloudMaterial);
								cloudMesh.position.x = x * 40 - numX * 20;
								cloudMesh.position.y = (150 + y * 40) - sceneCorrection;
								cloudMesh.position.z = z * 40 - numZ * 20;
								scene.add(cloudMesh);
								collidableObjects.push(cloudMesh);
							}
						}
					}
				}
				thingYouLastSteppedOn = collidableObjects[0]; //TODO: maybe this doesn't make sense
				
			}


			function initEvents() {

				cursorEvents = new CursorEvents( scene );
				cursorEvents.enableMouseEvents( camera );

				// cursorEvents.addObject( cube );

				var playSound = function( event ) {
					if (!sound) loadSoundEffect();
					sound.play();
					console.log("playSound"); // For debugging, in case sound is muted.
				};

				// if ( inAltspace ) {
				// 	// TEMP until we implement bubbling, currently event fired on child mesh.
				// 	cube.children[0].addEventListener( "cursordown", playSound );
				// } else {
				// 	cube.addEventListener( "cursordown", playSound );
				// }

				// In addition to defining event listeners, you can apply pre-made effects
				// or create your own effects that work with the CursorEvents framework.

				var dragEffect = new DragPlaneEffect( { firebaseSync: firebaseSync });
				var hoverEffect = new ColorHoverEffect( { color: new THREE.Color(0, 1, 1) });
				// hover listens for cursorenter / cursorleave for hover over / out

				// cursorEvents.addEffect( dragEffect, cube );
				// cursorEvents.addEffect( hoverEffect, cube );
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener("keydown", function() { console.log("keypress"); }, false);
			}

			function initSync() {

				var firebaseRootUrl = "https://altspace-apps.firebaseio.com/";
				var appId = "spinning-cube";

				var params = { authTokenPath: "AltspaceSDK/examples/tokens/spinning-cube-token.txt" };

				firebaseSync = new FirebaseSync( firebaseRootUrl, appId, params );

				// firebaseSync.addObject( cube, "cube" );
				firebaseSync.connect( onSyncReady );

			}

			function loadSoundEffect() {

				// Load sound effect. Chromium doesn't support mp3 so include wav too.
				var ext = (new Audio()).canPlayType('audio/mpeg') ? ".mp3" : ".wav";
				sound = new Audio("sounds/drippy" + ext);

			}

			function onWindowResize() {

				if ( inAltspace ) return ; // Resize not supported yet.

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate( timestamp ) {
				var frameTime = ( timestamp - prevTimestamp ) * 0.001;
				prevTimestamp = timestamp;
				requestAnimationFrame( animate );
				cursorEvents.update();
				stats.update();
          		
          		updateMovement(frameTime);
          		fixCollisions();
				render(frameTime);
			}
			
			var xspeed = 0;
			var zspeed = 0;
			var yspeed = 0;
			var air =  0.09375; // airborne acceleration = 2x land acceleration
			var acc =  0.046875;
			var dec =  0.8;
			var friction =  0.046875;
			var top =  6;
			var ytop =  16; // fastest you can fall
			var grv = 0.21875;
			var jumpPressed = false;
			
			function updateMovement( frameTime ) {
				if (pet.position.y < -500){
					pet.position.x = 0;
					pet.position.y = 600;
					pet.position.z = 0;
					xspeed =0;
					yspeed =0;
				}
				if (keyboard.pressed("p")){
					console.log(pet.position);
				}
				var inTheAir = Math.abs(pet.position.y - yourHeightWhenYouWereLastOnTheGround) > 0.1;
				var newJumpPressed = keyboard.pressed("v");
				if (inTheAir){
					yspeed += grv;
					if (newJumpPressed == false && jumpPressed == true && yspeed < 0 && yspeed < -4 ){
						yspeed = -4;
						newJumpPressed = jumpPressed;
					}
					if (yspeed > ytop) yspeed = ytop;
					
					if (keyboard.pressed("i")){
						zspeed -= air;
						if (zspeed < -top) zspeed = -top;
					}
					if (keyboard.pressed("k")){
						zspeed += air;
						if (zspeed > top) zspeed = top;
					}
					if (keyboard.pressed("j")){
						xspeed -= air;
						if (xspeed < -top) xspeed = -top;
					}
					if (keyboard.pressed("l")){
						xspeed += air;
						if (xspeed > top) xspeed = top;
					}
				}
				else {
					if (newJumpPressed){
						yspeed = -12.5;
						jumpPressed = newJumpPressed;
					}
					// Apply friction if up or down not pressed
					if (!keyboard.pressed("i") && !keyboard.pressed("k")){
						if (zspeed > 0){
							zspeed -= friction;
							if (zspeed < 0) zspeed = 0;
						}
						else {
							zspeed += friction;
							if (zspeed > 0) zspeed = 0;
						}
					}
					
					// Apply friction if left or right not pressed
					if (!keyboard.pressed("j") && !keyboard.pressed("l")){
						if (xspeed > 0){
							xspeed -= friction;
							if (xspeed < 0) xspeed = 0;
						}
						else {
							xspeed += friction;
							if (xspeed > 0) xspeed = 0;
						}
					}
					
					if (keyboard.pressed("k")){
						if (zspeed > 0){
							zspeed += acc;
						}
						else {
							zspeed += dec;
						}
						if (zspeed > top) zspeed = top;
					}
					if (keyboard.pressed("i")){
						if (zspeed < 0){
							zspeed -= acc;
						}
						else {
							zspeed -= dec;
						}
						if (zspeed < -top) zspeed = -top;
					}
					
					if (keyboard.pressed("l")){
						if (xspeed > 0){
							xspeed += acc;
						}
						else {
							xspeed += dec;
						}
						if (xspeed > top) xspeed = top;
					}
					if (keyboard.pressed("j")){
						if (xspeed < 0){
							xspeed -= acc;
						}
						else {
							xspeed -= dec;
						}
						if (xspeed < -top) xspeed = -top;
					}
				}
				
				
				pet.position.x += xspeed * frameTime * 10;
				pet.position.z += zspeed * frameTime * 10;
				//gravity 
				pet.position.y -= yspeed * frameTime * 10;
				
			}
			
			function fixCollisions()
			{
				var oneFix = false;
				for (var i=0; i< collidableObjects.length; i++){
					if (oneFix) break;
					var collides = true;
					var box = collidableObjects[i];
					
					if ( Math.abs( box.position.x - pet.position.x ) > (box.geometry.parameters.width/2 + pet.geometry.parameters.width/2)){
						collides = false;
					}
					if ( Math.abs( box.position.y - pet.position.y ) > (box.geometry.parameters.height/2 + pet.geometry.parameters.height/2)){
						collides = false;
					}
					if ( Math.abs( box.position.z - pet.position.z ) > (box.geometry.parameters.depth/2 + pet.geometry.parameters.depth/2)){
						collides = false;
					}
					
					if (collides){
						//oneFix = true;
						var diff = new THREE.Vector3().subVectors(box.position, pet.position);
						var ray = new THREE.Raycaster( pet.position, diff.normalize()); 
						var intersects = ray.intersectObjects( collidableObjects, true);

						if (intersects[0]){
							if (intersects[0].face.normal.x != 0){
								pet.position.x = box.position.x + (box.geometry.parameters.width/2 + pet.geometry.parameters.width/2)*intersects[0].face.normal.x;
								xspeed = 0;
							}
							if (intersects[0].face.normal.y != 0){
								pet.position.y = box.position.y + (box.geometry.parameters.height/2 + pet.geometry.parameters.height/2)*intersects[0].face.normal.y;
			            		thingYouLastSteppedOn = box;
			            		yourHeightWhenYouWereLastOnTheGround = pet.position.y;
							}
							if (intersects[0].face.normal.z != 0){
								pet.position.z = box.position.z + (box.geometry.parameters.depth/2 + pet.geometry.parameters.depth/2)*intersects[0].face.normal.z;
								zspeed=0;
							}
						}
						else {
							console.log("something went wrong with collisions");
						}
					}
				}
			}

			function render(timestamp){
				if(inAltspace){
					altRenderer.render( scene, camera );
				}
				else{
					renderer.render( scene, camera );
					controls.update(timestamp);
				}
			}

		</script>
	</body>
</html>
